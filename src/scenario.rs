use crate::model::entity_data::*;
use crate::model::population::PopulationBreakdown;
use crate::model::*;
use crate::sim::extra_keys as K;
use crate::sim::{SimConfig, SimSystem, run};

/// IDs returned by [`Scenario::add_settlement_standalone`].
pub struct SettlementSetup {
    pub settlement: u64,
    pub faction: u64,
    pub region: u64,
}

/// IDs returned by [`Scenario::add_kingdom`] / [`Scenario::add_kingdom_with`].
pub struct KingdomIds {
    pub faction: u64,
    pub region: u64,
    pub settlement: u64,
    pub leader: u64,
}

/// IDs returned by [`Scenario::add_war_between`].
pub struct WarIds {
    pub attacker: KingdomIds,
    pub defender: KingdomIds,
    pub army: u64,
}

// -- Builder-style ref types (generated by scenario_ref! macro) --

macro_rules! scenario_ref {
    ($Ref:ident, $DataTy:ty, $as_mut:ident) => {
        #[must_use = "call .id() to get the entity ID"]
        pub struct $Ref<'a> {
            scenario: &'a mut Scenario,
            id: u64,
        }

        impl<'a> $Ref<'a> {
            fn data_mut(&mut self) -> &mut $DataTy {
                self.scenario
                    .world
                    .entities
                    .get_mut(&self.id)
                    .unwrap()
                    .data
                    .$as_mut()
                    .unwrap()
            }

            /// Terminate the chain and return the entity ID.
            pub fn id(self) -> u64 {
                self.id
            }
        }
    };
}

/// Generate a standard `with()` escape-hatch for a scenario ref type.
macro_rules! scenario_ref_with {
    ($Ref:ident, $DataTy:ty) => {
        impl $Ref<'_> {
            /// Escape hatch: apply an arbitrary closure to the data.
            pub fn with(mut self, f: impl FnOnce(&mut $DataTy)) -> Self {
                f(self.data_mut());
                self
            }
        }
    };
}

scenario_ref!(FactionRef, FactionData, as_faction_mut);
scenario_ref!(SettlementRef, SettlementData, as_settlement_mut);
scenario_ref!(PersonRef, PersonData, as_person_mut);
scenario_ref!(ArmyRef, ArmyData, as_army_mut);
scenario_ref!(BuildingRef, BuildingData, as_building_mut);
scenario_ref!(RegionRef, RegionData, as_region_mut);
scenario_ref!(CultureRef, CultureData, as_culture_mut);
scenario_ref!(DiseaseRef, DiseaseData, as_disease_mut);
scenario_ref!(KnowledgeRef, KnowledgeData, as_knowledge_mut);
scenario_ref!(
    GeographicFeatureRef,
    GeographicFeatureData,
    as_geographic_feature_mut
);
scenario_ref!(RiverRef, RiverData, as_river_mut);
scenario_ref!(
    ResourceDepositRef,
    ResourceDepositData,
    as_resource_deposit_mut
);
scenario_ref!(ManifestationRef, ManifestationData, as_manifestation_mut);
scenario_ref!(ItemRef, ItemData, as_item_mut);
scenario_ref!(ReligionRef, ReligionData, as_religion_mut);
scenario_ref!(DeityRef, DeityData, as_deity_mut);

// Standard `with()` for all ref types except SettlementRef (which needs sync_population).
scenario_ref_with!(FactionRef, FactionData);
scenario_ref_with!(PersonRef, PersonData);
scenario_ref_with!(ArmyRef, ArmyData);
scenario_ref_with!(BuildingRef, BuildingData);
scenario_ref_with!(RegionRef, RegionData);
scenario_ref_with!(CultureRef, CultureData);
scenario_ref_with!(DiseaseRef, DiseaseData);
scenario_ref_with!(KnowledgeRef, KnowledgeData);
scenario_ref_with!(GeographicFeatureRef, GeographicFeatureData);
scenario_ref_with!(RiverRef, RiverData);
scenario_ref_with!(ResourceDepositRef, ResourceDepositData);
scenario_ref_with!(ManifestationRef, ManifestationData);
scenario_ref_with!(ItemRef, ItemData);
scenario_ref_with!(ReligionRef, ReligionData);
scenario_ref_with!(DeityRef, DeityData);

/// SettlementRef::with() calls sync_population() after the user closure runs.
impl SettlementRef<'_> {
    pub fn with(mut self, f: impl FnOnce(&mut SettlementData)) -> Self {
        f(self.data_mut());
        self.data_mut().sync_population();
        self
    }
}

// -- Field-specific builder methods --

impl FactionRef<'_> {
    pub fn government_type(mut self, v: GovernmentType) -> Self {
        self.data_mut().government_type = v;
        self
    }
    pub fn stability(mut self, v: f64) -> Self {
        self.data_mut().stability = v;
        self
    }
    pub fn happiness(mut self, v: f64) -> Self {
        self.data_mut().happiness = v;
        self
    }
    pub fn legitimacy(mut self, v: f64) -> Self {
        self.data_mut().legitimacy = v;
        self
    }
    pub fn treasury(mut self, v: f64) -> Self {
        self.data_mut().treasury = v;
        self
    }
    pub fn alliance_strength(mut self, v: f64) -> Self {
        self.data_mut().alliance_strength = v;
        self
    }
    pub fn primary_culture(mut self, v: Option<u64>) -> Self {
        self.data_mut().primary_culture = v;
        self
    }
    pub fn prestige(mut self, v: f64) -> Self {
        self.data_mut().prestige = v;
        self
    }
    pub fn primary_religion(mut self, v: Option<u64>) -> Self {
        self.data_mut().primary_religion = v;
        self
    }
}

impl SettlementRef<'_> {
    pub fn population(mut self, v: u32) -> Self {
        let d = self.data_mut();
        d.population = v;
        d.population_breakdown = PopulationBreakdown::from_total(v);
        self
    }
    pub fn prosperity(mut self, v: f64) -> Self {
        self.data_mut().prosperity = v;
        self
    }
    pub fn treasury(mut self, v: f64) -> Self {
        self.data_mut().treasury = v;
        self
    }
    pub fn fortification_level(mut self, v: u8) -> Self {
        self.data_mut().fortification_level = v;
        self
    }
    pub fn resources(mut self, v: Vec<ResourceType>) -> Self {
        self.data_mut().resources = v;
        self
    }
    pub fn prestige(mut self, v: f64) -> Self {
        self.data_mut().prestige = v;
        self
    }
    pub fn plague_immunity(mut self, v: f64) -> Self {
        self.data_mut().plague_immunity = v;
        self
    }
    pub fn cultural_tension(mut self, v: f64) -> Self {
        self.data_mut().cultural_tension = v;
        self
    }
    pub fn dominant_culture(mut self, v: Option<u64>) -> Self {
        self.data_mut().dominant_culture = v;
        self
    }
    pub fn culture_makeup(mut self, v: std::collections::BTreeMap<u64, f64>) -> Self {
        self.data_mut().culture_makeup = v;
        self
    }
    pub fn dominant_religion(mut self, v: Option<u64>) -> Self {
        self.data_mut().dominant_religion = v;
        self
    }
    pub fn religion_makeup(mut self, v: std::collections::BTreeMap<u64, f64>) -> Self {
        self.data_mut().religion_makeup = v;
        self
    }
    pub fn religious_tension(mut self, v: f64) -> Self {
        self.data_mut().religious_tension = v;
        self
    }
}

impl PersonRef<'_> {
    pub fn birth_year(mut self, v: u32) -> Self {
        self.data_mut().birth_year = v;
        self
    }
    pub fn sex(mut self, v: Sex) -> Self {
        self.data_mut().sex = v;
        self
    }
    pub fn role(mut self, v: Role) -> Self {
        self.data_mut().role = v;
        self
    }
    pub fn traits(mut self, v: Vec<Trait>) -> Self {
        self.data_mut().traits = v;
        self
    }
    pub fn add_trait(mut self, t: Trait) -> Self {
        self.data_mut().traits.push(t);
        self
    }
    pub fn culture_id(mut self, v: Option<u64>) -> Self {
        self.data_mut().culture_id = v;
        self
    }
    pub fn prestige(mut self, v: f64) -> Self {
        self.data_mut().prestige = v;
        self
    }
    pub fn last_action_year(mut self, v: u32) -> Self {
        self.data_mut().last_action_year = v;
        self
    }
}

impl ArmyRef<'_> {
    pub fn morale(mut self, v: f64) -> Self {
        self.data_mut().morale = v;
        self
    }
    pub fn supply(mut self, v: f64) -> Self {
        self.data_mut().supply = v;
        self
    }
    pub fn strength(mut self, v: u32) -> Self {
        self.data_mut().strength = v;
        self
    }
}

impl ItemRef<'_> {
    pub fn item_type(mut self, v: ItemType) -> Self {
        self.data_mut().item_type = v;
        self
    }
    pub fn material(mut self, v: &str) -> Self {
        self.data_mut().material = v.to_string();
        self
    }
    pub fn resonance(mut self, v: f64) -> Self {
        self.data_mut().resonance = v;
        self
    }
    pub fn condition(mut self, v: f64) -> Self {
        self.data_mut().condition = v;
        self
    }
}

impl ReligionRef<'_> {
    pub fn fervor(mut self, v: f64) -> Self {
        self.data_mut().fervor = v;
        self
    }
    pub fn proselytism(mut self, v: f64) -> Self {
        self.data_mut().proselytism = v;
        self
    }
    pub fn orthodoxy(mut self, v: f64) -> Self {
        self.data_mut().orthodoxy = v;
        self
    }
    pub fn tenets(mut self, v: Vec<ReligiousTenet>) -> Self {
        self.data_mut().tenets = v;
        self
    }
}

impl DeityRef<'_> {
    pub fn domain(mut self, v: DeityDomain) -> Self {
        self.data_mut().domain = v;
        self
    }
    pub fn worship_strength(mut self, v: f64) -> Self {
        self.data_mut().worship_strength = v;
        self
    }
}

/// Fluent builder for constructing World state.
///
/// Handles event creation automatically and uses `EntityData::default_for_kind()`
/// plus closure-based field mutation, so adding new struct fields never breaks callers.
///
/// Used by tests for deterministic scenario setup, and will serve as the foundation
/// for future template/premade-map starting points.
pub struct Scenario {
    world: World,
    setup_event: u64,
    start_year: u32,
}

impl Default for Scenario {
    fn default() -> Self {
        Self::new()
    }
}

impl Scenario {
    /// Create a new scenario starting at year 1.
    pub fn new() -> Self {
        Self::at_year(1)
    }

    /// Create a new scenario starting at the given year.
    pub fn at_year(year: u32) -> Self {
        let mut world = World::new();
        world.current_time = SimTimestamp::from_year(year);
        let setup_event = world.add_event(
            EventKind::Custom("test_setup".to_string()),
            SimTimestamp::from_year(year),
            "Scenario setup".to_string(),
        );
        Self {
            world,
            setup_event,
            start_year: year,
        }
    }

    // -- Entity creation --

    /// Add a region with default terrain ("plains").
    pub fn add_region(&mut self, name: &str) -> u64 {
        self.add_region_with(name, |_| {})
    }

    /// Add a region, customizing its data via closure.
    pub fn add_region_with(&mut self, name: &str, modify: impl FnOnce(&mut RegionData)) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Region);
        let EntityData::Region(ref mut rd) = data else {
            unreachable!()
        };
        rd.terrain = Terrain::Plains;
        modify(rd);
        self.world.add_entity(
            EntityKind::Region,
            name.to_string(),
            None,
            data,
            self.setup_event,
        )
    }

    /// Add a faction with sensible defaults (treasury=100, stability/happiness/legitimacy=0.5).
    pub fn add_faction(&mut self, name: &str) -> u64 {
        self.add_faction_with(name, |_| {})
    }

    /// Add a faction, customizing its data via closure.
    pub fn add_faction_with(&mut self, name: &str, modify: impl FnOnce(&mut FactionData)) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Faction);
        let EntityData::Faction(ref mut fd) = data else {
            unreachable!()
        };
        fd.treasury = 100.0;
        modify(fd);
        let ts = self.ts();
        self.world.add_entity(
            EntityKind::Faction,
            name.to_string(),
            Some(ts),
            data,
            self.setup_event,
        )
    }

    /// Add a settlement with default pop=200, auto-creating MemberOf→faction and LocatedIn→region.
    /// Also sets the `capacity` extra to 2×population.
    pub fn add_settlement(&mut self, name: &str, faction: u64, region: u64) -> u64 {
        self.add_settlement_with(name, faction, region, |_| {})
    }

    /// Add a settlement, customizing its data via closure.
    /// Auto-creates MemberOf→faction and LocatedIn→region relationships.
    /// Syncs PopulationBreakdown if population was changed in the closure.
    pub fn add_settlement_with(
        &mut self,
        name: &str,
        faction: u64,
        region: u64,
        modify: impl FnOnce(&mut SettlementData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Settlement);
        let EntityData::Settlement(ref mut sd) = data else {
            unreachable!()
        };
        sd.population = 200;
        sd.population_breakdown = PopulationBreakdown::from_total(200);
        sd.prosperity = 0.5;
        modify(sd);
        sd.sync_population();
        let ts = self.ts();
        let ev = self.setup_event;
        let id =
            self.world
                .add_entity(EntityKind::Settlement, name.to_string(), Some(ts), data, ev);
        self.world
            .add_relationship(id, faction, RelationshipKind::MemberOf, ts, ev);
        self.world
            .add_relationship(id, region, RelationshipKind::LocatedIn, ts, ev);

        // Set capacity extra (used by demographics/economy)
        let pop = self.world.entities[&id]
            .data
            .as_settlement()
            .unwrap()
            .population;
        self.world
            .set_extra(id, K::CAPACITY, serde_json::json!(pop * 2), ev);
        id
    }

    /// Add a person with default birth_year and sex, auto-creating MemberOf→faction.
    pub fn add_person(&mut self, name: &str, faction: u64) -> u64 {
        self.add_person_with(name, faction, |_| {})
    }

    /// Add a person, customizing its data via closure. Auto-creates MemberOf→faction.
    pub fn add_person_with(
        &mut self,
        name: &str,
        faction: u64,
        modify: impl FnOnce(&mut PersonData),
    ) -> u64 {
        let id = self.add_person_standalone_with(name, modify);
        let ts = self.ts();
        self.world.add_relationship(
            id,
            faction,
            RelationshipKind::MemberOf,
            ts,
            self.setup_event,
        );
        id
    }

    /// Add a person with MemberOf→faction AND LocatedIn→settlement.
    pub fn add_person_in(&mut self, name: &str, faction: u64, settlement: u64) -> u64 {
        self.add_person_in_with(name, faction, settlement, |_| {})
    }

    /// Add a person with MemberOf→faction AND LocatedIn→settlement, customizing via closure.
    pub fn add_person_in_with(
        &mut self,
        name: &str,
        faction: u64,
        settlement: u64,
        modify: impl FnOnce(&mut PersonData),
    ) -> u64 {
        let id = self.add_person_with(name, faction, modify);
        let ts = self.ts();
        self.world.add_relationship(
            id,
            settlement,
            RelationshipKind::LocatedIn,
            ts,
            self.setup_event,
        );
        id
    }

    /// Add a person without any faction membership.
    pub fn add_person_standalone(&mut self, name: &str) -> u64 {
        self.add_person_standalone_with(name, |_| {})
    }

    /// Add a person without faction membership, customizing via closure.
    pub fn add_person_standalone_with(
        &mut self,
        name: &str,
        modify: impl FnOnce(&mut PersonData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Person);
        let EntityData::Person(ref mut pd) = data else {
            unreachable!()
        };
        pd.birth_year = self.start_year.saturating_sub(30);
        pd.sex = Sex::Male;
        modify(pd);
        let ts = self.ts();
        self.world.add_entity(
            EntityKind::Person,
            name.to_string(),
            Some(ts),
            data,
            self.setup_event,
        )
    }

    /// Add an army with given strength, auto-creating MemberOf→faction, LocatedIn→region,
    /// and setting faction_id/home_region_id/starting_strength extras.
    pub fn add_army(&mut self, name: &str, faction: u64, region: u64, strength: u32) -> u64 {
        self.add_army_with(name, faction, region, strength, |_| {})
    }

    /// Add an army, customizing its data via closure.
    pub fn add_army_with(
        &mut self,
        name: &str,
        faction: u64,
        region: u64,
        strength: u32,
        modify: impl FnOnce(&mut ArmyData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Army);
        let EntityData::Army(ref mut ad) = data else {
            unreachable!()
        };
        ad.strength = strength;
        ad.morale = 1.0;
        ad.supply = 3.0;
        modify(ad);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self
            .world
            .add_entity(EntityKind::Army, name.to_string(), Some(ts), data, ev);
        self.world
            .add_relationship(id, faction, RelationshipKind::MemberOf, ts, ev);
        self.world
            .add_relationship(id, region, RelationshipKind::LocatedIn, ts, ev);
        self.world
            .set_extra(id, K::FACTION_ID, serde_json::json!(faction), ev);
        self.world
            .set_extra(id, K::HOME_REGION_ID, serde_json::json!(region), ev);
        self.world
            .set_extra(id, K::STARTING_STRENGTH, serde_json::json!(strength), ev);
        id
    }

    /// Add a building, auto-creating LocatedIn→settlement.
    pub fn add_building(&mut self, building_type: BuildingType, settlement: u64) -> u64 {
        self.add_building_with(building_type, settlement, |_| {})
    }

    /// Add a building, customizing its data via closure. Auto-creates LocatedIn→settlement.
    pub fn add_building_with(
        &mut self,
        building_type: BuildingType,
        settlement: u64,
        modify: impl FnOnce(&mut BuildingData),
    ) -> u64 {
        let bt_name = building_type.to_string();
        let mut data = EntityData::default_for_kind(EntityKind::Building);
        let EntityData::Building(ref mut bd) = data else {
            unreachable!()
        };
        bd.building_type = building_type;
        bd.condition = 1.0;
        modify(bd);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self
            .world
            .add_entity(EntityKind::Building, bt_name, Some(ts), data, ev);
        self.world
            .add_relationship(id, settlement, RelationshipKind::LocatedIn, ts, ev);
        id
    }

    /// Add a culture with default data.
    pub fn add_culture(&mut self, name: &str) -> u64 {
        self.add_culture_with(name, |_| {})
    }

    /// Add a culture, customizing its data via closure.
    pub fn add_culture_with(&mut self, name: &str, modify: impl FnOnce(&mut CultureData)) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Culture);
        let EntityData::Culture(ref mut cd) = data else {
            unreachable!()
        };
        modify(cd);
        let ts = self.ts();
        self.world.add_entity(
            EntityKind::Culture,
            name.to_string(),
            Some(ts),
            data,
            self.setup_event,
        )
    }

    /// Add a disease entity with default data.
    pub fn add_disease(&mut self, name: &str) -> u64 {
        self.add_disease_with(name, |_| {})
    }

    /// Add a disease entity, customizing its data via closure.
    pub fn add_disease_with(&mut self, name: &str, modify: impl FnOnce(&mut DiseaseData)) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Disease);
        let EntityData::Disease(ref mut dd) = data else {
            unreachable!()
        };
        modify(dd);
        let ts = self.ts();
        self.world.add_entity(
            EntityKind::Disease,
            name.to_string(),
            Some(ts),
            data,
            self.setup_event,
        )
    }

    /// Add a knowledge entity with default data.
    pub fn add_knowledge(
        &mut self,
        name: &str,
        category: KnowledgeCategory,
        origin_settlement: u64,
    ) -> u64 {
        self.add_knowledge_with(name, category, origin_settlement, |_| {})
    }

    /// Add a knowledge entity, customizing its data via closure.
    pub fn add_knowledge_with(
        &mut self,
        name: &str,
        category: KnowledgeCategory,
        origin_settlement: u64,
        modify: impl FnOnce(&mut KnowledgeData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Knowledge);
        let EntityData::Knowledge(ref mut kd) = data else {
            unreachable!()
        };
        kd.category = category;
        kd.origin_settlement_id = origin_settlement;
        kd.origin_year = self.start_year;
        kd.source_event_id = self.setup_event;
        modify(kd);
        let ts = self.ts();
        self.world.add_entity(
            EntityKind::Knowledge,
            name.to_string(),
            Some(ts),
            data,
            self.setup_event,
        )
    }

    /// Add a geographic feature with default data, auto-creating LocatedIn→region.
    pub fn add_geographic_feature(
        &mut self,
        name: &str,
        feature_type: FeatureType,
        region: u64,
    ) -> u64 {
        self.add_geographic_feature_with(name, feature_type, region, |_| {})
    }

    /// Add a geographic feature, customizing its data via closure.
    /// Auto-creates LocatedIn→region.
    pub fn add_geographic_feature_with(
        &mut self,
        name: &str,
        feature_type: FeatureType,
        region: u64,
        modify: impl FnOnce(&mut GeographicFeatureData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::GeographicFeature);
        let EntityData::GeographicFeature(ref mut gf) = data else {
            unreachable!()
        };
        gf.feature_type = feature_type;
        modify(gf);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self.world.add_entity(
            EntityKind::GeographicFeature,
            name.to_string(),
            Some(ts),
            data,
            ev,
        );
        self.world
            .add_relationship(id, region, RelationshipKind::LocatedIn, ts, ev);
        id
    }

    /// Add a river, auto-creating FlowsThrough for each region in the path.
    pub fn add_river(&mut self, name: &str, region_path: &[u64]) -> u64 {
        self.add_river_with(name, region_path, |_| {})
    }

    /// Add a river, customizing its data via closure.
    /// Auto-creates FlowsThrough for each region in the path.
    pub fn add_river_with(
        &mut self,
        name: &str,
        region_path: &[u64],
        modify: impl FnOnce(&mut RiverData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::River);
        let EntityData::River(ref mut rd) = data else {
            unreachable!()
        };
        rd.region_path = region_path.to_vec();
        rd.length = region_path.len() as u32;
        modify(rd);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self
            .world
            .add_entity(EntityKind::River, name.to_string(), Some(ts), data, ev);
        for &region in region_path {
            self.world
                .add_relationship(id, region, RelationshipKind::FlowsThrough, ts, ev);
        }
        id
    }

    /// Add a resource deposit, auto-creating LocatedIn→region.
    /// Defaults: quantity=100, quality=0.5, discovered=true.
    pub fn add_resource_deposit(
        &mut self,
        name: &str,
        resource_type: ResourceType,
        region: u64,
    ) -> u64 {
        self.add_resource_deposit_with(name, resource_type, region, |_| {})
    }

    /// Add a resource deposit, customizing its data via closure.
    /// Auto-creates LocatedIn→region.
    pub fn add_resource_deposit_with(
        &mut self,
        name: &str,
        resource_type: ResourceType,
        region: u64,
        modify: impl FnOnce(&mut ResourceDepositData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::ResourceDeposit);
        let EntityData::ResourceDeposit(ref mut rd) = data else {
            unreachable!()
        };
        rd.resource_type = resource_type;
        rd.quantity = 100;
        rd.quality = 0.5;
        rd.discovered = true;
        modify(rd);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self.world.add_entity(
            EntityKind::ResourceDeposit,
            name.to_string(),
            Some(ts),
            data,
            ev,
        );
        self.world
            .add_relationship(id, region, RelationshipKind::LocatedIn, ts, ev);
        id
    }

    /// Add a manifestation of knowledge, auto-creating HeldBy→holder.
    /// Defaults: accuracy=1.0, completeness=1.0, condition=1.0,
    /// derivation_method="witnessed", created_year=start_year.
    pub fn add_manifestation(
        &mut self,
        name: &str,
        knowledge: u64,
        medium: Medium,
        holder: u64,
    ) -> u64 {
        self.add_manifestation_with(name, knowledge, medium, holder, |_| {})
    }

    /// Add a manifestation of knowledge, customizing its data via closure.
    /// Auto-creates HeldBy→holder.
    pub fn add_manifestation_with(
        &mut self,
        name: &str,
        knowledge: u64,
        medium: Medium,
        holder: u64,
        modify: impl FnOnce(&mut ManifestationData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Manifestation);
        let EntityData::Manifestation(ref mut md) = data else {
            unreachable!()
        };
        md.knowledge_id = knowledge;
        md.medium = medium;
        md.accuracy = 1.0;
        md.completeness = 1.0;
        md.condition = 1.0;
        md.derivation_method = DerivationMethod::Witnessed;
        md.created_year = self.start_year;
        modify(md);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self.world.add_entity(
            EntityKind::Manifestation,
            name.to_string(),
            Some(ts),
            data,
            ev,
        );
        self.world
            .add_relationship(id, holder, RelationshipKind::HeldBy, ts, ev);
        id
    }

    /// Add an item, auto-creating HeldBy→holder.
    /// Defaults: resonance=0.0, condition=1.0, creation_year=start_year.
    pub fn add_item(&mut self, item_type: ItemType, material: &str, holder: u64) -> u64 {
        self.add_item_with(item_type, material, holder, |_| {})
    }

    /// Add an item, customizing its data via closure. Auto-creates HeldBy→holder.
    pub fn add_item_with(
        &mut self,
        item_type: ItemType,
        material: &str,
        holder: u64,
        modify: impl FnOnce(&mut ItemData),
    ) -> u64 {
        let name = format!("{} {}", material, item_type);
        let mut data = EntityData::default_for_kind(EntityKind::Item);
        let EntityData::Item(ref mut id) = data else {
            unreachable!()
        };
        id.item_type = item_type;
        id.material = material.to_string();
        id.condition = 1.0;
        id.creation_year = self.start_year;
        modify(id);
        let ts = self.ts();
        let ev = self.setup_event;
        let item_id = self
            .world
            .add_entity(EntityKind::Item, name, Some(ts), data, ev);
        self.world
            .add_relationship(item_id, holder, RelationshipKind::HeldBy, ts, ev);
        item_id
    }

    /// Add a religion entity with default data.
    pub fn add_religion(&mut self, name: &str) -> u64 {
        self.add_religion_with(name, |_| {})
    }

    /// Add a religion entity, customizing its data via closure.
    pub fn add_religion_with(&mut self, name: &str, modify: impl FnOnce(&mut ReligionData)) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Religion);
        let EntityData::Religion(ref mut rd) = data else {
            unreachable!()
        };
        modify(rd);
        let ts = self.ts();
        self.world.add_entity(
            EntityKind::Religion,
            name.to_string(),
            Some(ts),
            data,
            self.setup_event,
        )
    }

    /// Add a deity entity linked to a religion via MemberOf.
    pub fn add_deity(&mut self, name: &str, religion: u64) -> u64 {
        self.add_deity_with(name, religion, |_| {})
    }

    /// Add a deity entity linked to a religion via MemberOf, customizing via closure.
    pub fn add_deity_with(
        &mut self,
        name: &str,
        religion: u64,
        modify: impl FnOnce(&mut DeityData),
    ) -> u64 {
        let mut data = EntityData::default_for_kind(EntityKind::Deity);
        let EntityData::Deity(ref mut dd) = data else {
            unreachable!()
        };
        modify(dd);
        let ts = self.ts();
        let ev = self.setup_event;
        let id = self
            .world
            .add_entity(EntityKind::Deity, name.to_string(), Some(ts), data, ev);
        self.world
            .add_relationship(id, religion, RelationshipKind::MemberOf, ts, ev);
        id
    }

    /// Create N males + N females placed in a settlement with faction membership.
    /// Returns the IDs of all created people.
    pub fn add_population(
        &mut self,
        faction: u64,
        settlement: u64,
        count_per_sex: usize,
    ) -> Vec<u64> {
        let mut ids = Vec::with_capacity(count_per_sex * 2);
        for i in 0..count_per_sex {
            ids.push(
                self.add_person_in_with(&format!("Male_{i}"), faction, settlement, |pd| {
                    pd.sex = Sex::Male
                }),
            );
        }
        for i in 0..count_per_sex {
            ids.push(
                self.add_person_in_with(&format!("Female_{i}"), faction, settlement, |pd| {
                    pd.sex = Sex::Female
                }),
            );
        }
        ids
    }

    // -- Standalone settlement shorthand --

    /// Create a region + faction + settlement in one call with default data.
    /// Names derived from the given name (e.g. "Town" → "Town Region", "Town Faction").
    pub fn add_settlement_standalone(&mut self, name: &str) -> SettlementSetup {
        self.add_settlement_standalone_with(name, |_| {}, |_| {})
    }

    /// Create a region + faction + settlement in one call with customization closures.
    pub fn add_settlement_standalone_with(
        &mut self,
        name: &str,
        modify_faction: impl FnOnce(&mut FactionData),
        modify_settlement: impl FnOnce(&mut SettlementData),
    ) -> SettlementSetup {
        let region = self.add_region(&format!("{name} Region"));
        let faction = self.add_faction_with(&format!("{name} Faction"), modify_faction);
        let settlement = self.add_settlement_with(name, faction, region, modify_settlement);
        SettlementSetup {
            settlement,
            faction,
            region,
        }
    }

    /// Like `add_settlement_standalone` but makes the new region adjacent to `neighbor_region`.
    pub fn add_rival_settlement(&mut self, name: &str, neighbor_region: u64) -> SettlementSetup {
        self.add_rival_settlement_with(name, neighbor_region, |_| {}, |_| {})
    }

    /// Like `add_settlement_standalone_with` but makes the new region adjacent to `neighbor_region`.
    pub fn add_rival_settlement_with(
        &mut self,
        name: &str,
        neighbor_region: u64,
        modify_faction: impl FnOnce(&mut FactionData),
        modify_settlement: impl FnOnce(&mut SettlementData),
    ) -> SettlementSetup {
        let setup = self.add_settlement_standalone_with(name, modify_faction, modify_settlement);
        self.make_adjacent(setup.region, neighbor_region);
        setup
    }

    // -- Relationship helpers --

    /// Make a person the leader of a faction (LeaderOf relationship).
    pub fn make_leader(&mut self, person: u64, faction: u64) {
        let ts = self.ts();
        self.world.add_relationship(
            person,
            faction,
            RelationshipKind::LeaderOf,
            ts,
            self.setup_event,
        );
    }

    /// Create a bidirectional relationship pair.
    fn make_bidirectional(
        &mut self,
        a: u64,
        b: u64,
        kind_ab: RelationshipKind,
        kind_ba: RelationshipKind,
    ) {
        let ts = self.ts();
        let ev = self.setup_event;
        self.world.add_relationship(a, b, kind_ab, ts, ev);
        self.world.add_relationship(b, a, kind_ba, ts, ev);
    }

    /// Make two regions adjacent (bidirectional AdjacentTo).
    pub fn make_adjacent(&mut self, region_a: u64, region_b: u64) {
        self.make_bidirectional(
            region_a,
            region_b,
            RelationshipKind::AdjacentTo,
            RelationshipKind::AdjacentTo,
        );
    }

    /// Put two factions at war (bidirectional AtWar).
    pub fn make_at_war(&mut self, faction_a: u64, faction_b: u64) {
        self.make_bidirectional(
            faction_a,
            faction_b,
            RelationshipKind::AtWar,
            RelationshipKind::AtWar,
        );
    }

    /// Make two factions allies (bidirectional Ally).
    pub fn make_allies(&mut self, faction_a: u64, faction_b: u64) {
        self.make_bidirectional(
            faction_a,
            faction_b,
            RelationshipKind::Ally,
            RelationshipKind::Ally,
        );
    }

    /// Make a parent-child relationship (bidirectional Parent + Child).
    pub fn make_parent_child(&mut self, parent: u64, child: u64) {
        self.make_bidirectional(
            parent,
            child,
            RelationshipKind::Parent,
            RelationshipKind::Child,
        );
    }

    /// Make two people spouses (bidirectional Spouse).
    pub fn make_spouse(&mut self, person_a: u64, person_b: u64) {
        self.make_bidirectional(
            person_a,
            person_b,
            RelationshipKind::Spouse,
            RelationshipKind::Spouse,
        );
    }

    /// Make two factions enemies (bidirectional Enemy).
    pub fn make_enemies(&mut self, faction_a: u64, faction_b: u64) {
        self.make_bidirectional(
            faction_a,
            faction_b,
            RelationshipKind::Enemy,
            RelationshipKind::Enemy,
        );
    }

    /// End an entity (mark as dead/dissolved).
    pub fn end_entity(&mut self, entity: u64) {
        let ts = self.ts();
        self.world.end_entity(entity, ts, self.setup_event);
    }

    /// Add a single directed relationship between two entities.
    pub fn add_relationship(&mut self, source: u64, target: u64, kind: RelationshipKind) {
        let ts = self.ts();
        self.world
            .add_relationship(source, target, kind, ts, self.setup_event);
    }

    /// Create a trade route between two settlements (bidirectional TradeRoute).
    pub fn make_trade_route(&mut self, settlement_a: u64, settlement_b: u64) {
        self.make_bidirectional(
            settlement_a,
            settlement_b,
            RelationshipKind::TradeRoute,
            RelationshipKind::TradeRoute,
        );
    }

    /// Set an extra property on an entity.
    pub fn set_extra(&mut self, entity: u64, key: &str, value: serde_json::Value) {
        self.world.set_extra(entity, key, value, self.setup_event);
    }

    // -- Entity mutation (generated by scenario_modify! macro) --
}

macro_rules! scenario_modify {
    ($($method:ident, $DataTy:ty, $as_mut:ident, $label:expr;)*) => {
        impl Scenario {
            $(
                pub fn $method(&mut self, id: u64, modify: impl FnOnce(&mut $DataTy)) {
                    let entity = self.world.entities.get_mut(&id)
                        .unwrap_or_else(|| panic!("{}: entity {id} not found", stringify!($method)));
                    let d = entity.data.$as_mut()
                        .unwrap_or_else(|| panic!("{}: entity {id} is not a {}", stringify!($method), $label));
                    modify(d);
                }
            )*
        }
    };
}

scenario_modify! {
    modify_faction, FactionData, as_faction_mut, "faction";
    modify_person, PersonData, as_person_mut, "person";
    modify_army, ArmyData, as_army_mut, "army";
    modify_building, BuildingData, as_building_mut, "building";
    modify_region, RegionData, as_region_mut, "region";
    modify_culture, CultureData, as_culture_mut, "culture";
    modify_disease, DiseaseData, as_disease_mut, "disease";
    modify_knowledge, KnowledgeData, as_knowledge_mut, "knowledge";
    modify_geographic_feature, GeographicFeatureData, as_geographic_feature_mut, "geographic feature";
    modify_river, RiverData, as_river_mut, "river";
    modify_resource_deposit, ResourceDepositData, as_resource_deposit_mut, "resource deposit";
    modify_manifestation, ManifestationData, as_manifestation_mut, "manifestation";
    modify_item, ItemData, as_item_mut, "item";
    modify_religion, ReligionData, as_religion_mut, "religion";
    modify_deity, DeityData, as_deity_mut, "deity";
}

impl Scenario {
    pub fn modify_settlement(&mut self, id: u64, modify: impl FnOnce(&mut SettlementData)) {
        let entity = self
            .world
            .entities
            .get_mut(&id)
            .unwrap_or_else(|| panic!("modify_settlement: entity {id} not found"));
        let d = entity
            .data
            .as_settlement_mut()
            .unwrap_or_else(|| panic!("modify_settlement: entity {id} is not a settlement"));
        modify(d);
        d.sync_population();
    }
}

impl Scenario {
    // -- Complex state helpers --

    /// Start a siege on a settlement with default timing (started at scenario time).
    pub fn start_siege(&mut self, settlement: u64, army: u64, attacker_faction: u64) {
        self.start_siege_with(settlement, army, attacker_faction, |_| {});
    }

    /// Start a siege on a settlement, customizing the siege state via closure.
    pub fn start_siege_with(
        &mut self,
        settlement: u64,
        army: u64,
        attacker_faction: u64,
        modify: impl FnOnce(&mut ActiveSiege),
    ) {
        let mut siege = ActiveSiege {
            attacker_army_id: army,
            attacker_faction_id: attacker_faction,
            started: SimTimestamp::from_year(self.start_year),
            months_elapsed: 0,
            civilian_deaths: 0,
        };
        modify(&mut siege);
        self.modify_settlement(settlement, |sd| {
            sd.active_siege = Some(siege);
        });
        self.set_extra(
            army,
            K::BESIEGING_SETTLEMENT_ID,
            serde_json::json!(settlement),
        );
    }

    /// Queue an action to be executed on the next tick.
    pub fn queue_action(&mut self, actor: u64, source: ActionSource, kind: ActionKind) {
        self.world.queue_action(Action {
            actor_id: actor,
            source,
            kind,
        });
    }

    /// Mark an entity as the player character.
    pub fn make_player(&mut self, entity: u64) {
        self.set_extra(entity, K::IS_PLAYER, serde_json::json!(true));
    }

    /// Add an active disaster to a settlement with default timing.
    pub fn add_active_disaster(
        &mut self,
        settlement: u64,
        disaster_type: DisasterType,
        severity: f64,
    ) {
        self.add_active_disaster_with(settlement, disaster_type, severity, |_| {});
    }

    /// Add an active disaster to a settlement, customizing via closure.
    pub fn add_active_disaster_with(
        &mut self,
        settlement: u64,
        disaster_type: DisasterType,
        severity: f64,
        modify: impl FnOnce(&mut ActiveDisaster),
    ) {
        let months = if disaster_type.is_persistent() { 6 } else { 0 };
        let mut disaster = ActiveDisaster {
            disaster_type,
            severity,
            started: SimTimestamp::from_year(self.start_year),
            months_remaining: months,
            total_deaths: 0,
        };
        modify(&mut disaster);
        self.modify_settlement(settlement, |sd| {
            sd.active_disaster = Some(disaster);
        });
    }

    /// Set an active disease on a settlement with default infection parameters.
    pub fn add_active_disease_on(&mut self, settlement: u64, disease: u64) {
        self.add_active_disease_on_with(settlement, disease, |_| {});
    }

    /// Set an active disease on a settlement, customizing via closure.
    pub fn add_active_disease_on_with(
        &mut self,
        settlement: u64,
        disease: u64,
        modify: impl FnOnce(&mut ActiveDisease),
    ) {
        let mut active = ActiveDisease {
            disease_id: disease,
            started_year: self.start_year,
            infection_rate: 0.3,
            peak_reached: false,
            total_deaths: 0,
        };
        modify(&mut active);
        self.modify_settlement(settlement, |sd| {
            sd.active_disease = Some(active);
        });
    }

    /// Add a tribute obligation from one faction to another.
    pub fn add_tribute(&mut self, payer: u64, payee: u64, amount: f64, years: u32) {
        self.set_extra(
            payer,
            &format!("tribute_{payee}"),
            serde_json::json!({
                "amount": amount,
                "years_remaining": years,
                "treaty_event_id": self.setup_event,
            }),
        );
    }

    /// Set war exhaustion on a faction.
    pub fn set_war_exhaustion(&mut self, faction: u64, value: f64) {
        self.set_extra(faction, K::WAR_EXHAUSTION, serde_json::json!(value));
    }

    /// Set diplomatic trust on a faction (default 1.0).
    pub fn set_diplomatic_trust(&mut self, faction: u64, trust: f64) {
        self.set_extra(faction, K::DIPLOMATIC_TRUST, serde_json::json!(trust));
    }

    /// Set the betrayal count on a faction.
    pub fn set_betrayal_count(&mut self, faction: u64, count: u64) {
        self.set_extra(faction, K::BETRAYAL_COUNT, serde_json::json!(count));
    }

    /// Add a succession claim on the given person for the given faction.
    pub fn add_claim(&mut self, person_id: u64, faction_id: u64, strength: f64) {
        let year = self.start_year;
        self.set_extra(
            person_id,
            &format!("claim_{faction_id}"),
            serde_json::json!({
                "strength": strength,
                "source": "bloodline",
                "year": year,
            }),
        );
    }

    /// Add a grievance from `holder` (faction or person) against `target` faction.
    pub fn add_grievance(&mut self, holder: u64, target: u64, severity: f64) {
        use crate::model::grievance::Grievance;
        let year = self.start_year;
        let entity = self
            .world
            .entities
            .get_mut(&holder)
            .expect("holder entity not found");
        let grievances = if let Some(fd) = entity.data.as_faction_mut() {
            &mut fd.grievances
        } else if let Some(pd) = entity.data.as_person_mut() {
            &mut pd.grievances
        } else {
            panic!("add_grievance: holder must be a faction or person");
        };
        grievances.insert(
            target,
            Grievance {
                severity,
                sources: vec!["scenario".to_string()],
                peak: severity,
                year,
            },
        );
    }

    // -- Composite builders --

    /// Create a kingdom: region + faction + settlement + leader with LeaderOf.
    /// Names derived from the given name (e.g. "Empire" → "Empire Region", "Empire Capital", "Empire Leader").
    pub fn add_kingdom(&mut self, name: &str) -> KingdomIds {
        self.add_kingdom_with(name, |_| {}, |_| {}, |_| {})
    }

    /// Create a kingdom with closures to customize faction, settlement, and leader data.
    pub fn add_kingdom_with(
        &mut self,
        name: &str,
        modify_faction: impl FnOnce(&mut FactionData),
        modify_settlement: impl FnOnce(&mut SettlementData),
        modify_leader: impl FnOnce(&mut PersonData),
    ) -> KingdomIds {
        let region = self.add_region(&format!("{name} Region"));
        let faction = self.add_faction_with(name, modify_faction);
        let settlement = self.add_settlement_with(
            &format!("{name} Capital"),
            faction,
            region,
            modify_settlement,
        );
        let leader = self.add_person_with(&format!("{name} Leader"), faction, |pd| {
            pd.role = Role::Warrior;
            modify_leader(pd);
        });
        self.make_leader(leader, faction);
        KingdomIds {
            faction,
            region,
            settlement,
            leader,
        }
    }

    /// Create a rival kingdom adjacent to an existing region.
    pub fn add_rival_kingdom(&mut self, name: &str, neighbor_region: u64) -> KingdomIds {
        self.add_rival_kingdom_with(name, neighbor_region, |_| {}, |_| {}, |_| {})
    }

    /// Create a rival kingdom adjacent to an existing region, with customization closures.
    pub fn add_rival_kingdom_with(
        &mut self,
        name: &str,
        neighbor_region: u64,
        modify_faction: impl FnOnce(&mut FactionData),
        modify_settlement: impl FnOnce(&mut SettlementData),
        modify_leader: impl FnOnce(&mut PersonData),
    ) -> KingdomIds {
        let k = self.add_kingdom_with(name, modify_faction, modify_settlement, modify_leader);
        self.make_adjacent(k.region, neighbor_region);
        k
    }

    /// Create two kingdoms at war with an army. The attacker's army is placed in the defender's region.
    pub fn add_war_between(
        &mut self,
        attacker_name: &str,
        defender_name: &str,
        army_strength: u32,
    ) -> WarIds {
        let attacker = self.add_kingdom(attacker_name);
        let defender = self.add_rival_kingdom(defender_name, attacker.region);
        self.make_at_war(attacker.faction, defender.faction);
        let army = self.add_army(
            &format!("{attacker_name} Army"),
            attacker.faction,
            defender.region,
            army_strength,
        );
        WarIds {
            attacker,
            defender,
            army,
        }
    }

    /// Add a player character in a faction.
    pub fn add_player_in(&mut self, name: &str, faction: u64) -> u64 {
        self.add_player_in_with(name, faction, |_| {})
    }

    /// Add a player character in a faction, customizing via closure.
    pub fn add_player_in_with(
        &mut self,
        name: &str,
        faction: u64,
        modify: impl FnOnce(&mut PersonData),
    ) -> u64 {
        let id = self.add_person_with(name, faction, modify);
        self.make_player(id);
        id
    }

    // -- Bulk operations --

    /// Create `count` people in a faction and settlement, with per-person customization.
    /// The closure receives the index (0..count) and a mutable reference to the person data.
    pub fn add_people(
        &mut self,
        faction: u64,
        settlement: u64,
        count: usize,
        modify: impl Fn(usize, &mut PersonData),
    ) -> Vec<u64> {
        let mut ids = Vec::with_capacity(count);
        for i in 0..count {
            ids.push(
                self.add_person_in_with(&format!("Person_{i}"), faction, settlement, |pd| {
                    modify(i, pd)
                }),
            );
        }
        ids
    }

    /// Modify all living settlements via closure.
    pub fn modify_all_settlements(&mut self, modify: impl Fn(&mut SettlementData)) {
        let ids: Vec<u64> = self
            .world
            .entities
            .values()
            .filter(|e| e.kind == EntityKind::Settlement && e.end.is_none())
            .map(|e| e.id)
            .collect();
        for id in ids {
            self.modify_settlement(id, &modify);
        }
    }

    /// Modify all living factions via closure.
    pub fn modify_all_factions(&mut self, modify: impl Fn(&mut FactionData)) {
        let ids: Vec<u64> = self
            .world
            .entities
            .values()
            .filter(|e| e.kind == EntityKind::Faction && e.end.is_none())
            .map(|e| e.id)
            .collect();
        for id in ids {
            self.modify_faction(id, &modify);
        }
    }

    /// Apply an active disease to multiple settlements at once.
    pub fn spread_disease(&mut self, disease: u64, settlements: &[u64]) {
        self.spread_disease_with(disease, settlements, |_| {});
    }

    /// Apply an active disease to multiple settlements, customizing each via closure.
    pub fn spread_disease_with(
        &mut self,
        disease: u64,
        settlements: &[u64],
        modify: impl Fn(&mut ActiveDisease),
    ) {
        for &s in settlements {
            let mut active = ActiveDisease {
                disease_id: disease,
                started_year: self.start_year,
                infection_rate: 0.3,
                peak_reached: false,
                total_deaths: 0,
            };
            modify(&mut active);
            self.modify_settlement(s, |sd| {
                sd.active_disease = Some(active);
            });
        }
    }

    /// Apply an active disaster to multiple settlements at once.
    pub fn spread_disaster(
        &mut self,
        settlements: &[u64],
        disaster_type: DisasterType,
        severity: f64,
    ) {
        for &s in settlements {
            self.add_active_disaster(s, disaster_type, severity);
        }
    }

    // -- Network topology helpers --

    /// Connect regions in a ring: A↔B↔C↔D↔A.
    pub fn connect_ring(&mut self, regions: &[u64]) {
        if regions.len() < 2 {
            return;
        }
        for window in regions.windows(2) {
            self.make_adjacent(window[0], window[1]);
        }
        if regions.len() > 2 {
            self.make_adjacent(*regions.last().unwrap(), regions[0]);
        }
    }

    /// Connect all regions to a central hub.
    pub fn connect_hub_and_spoke(&mut self, hub: u64, spokes: &[u64]) {
        for &spoke in spokes {
            self.make_adjacent(hub, spoke);
        }
    }

    /// Connect every region to every other region (complete graph).
    pub fn connect_all(&mut self, regions: &[u64]) {
        for i in 0..regions.len() {
            for j in (i + 1)..regions.len() {
                self.make_adjacent(regions[i], regions[j]);
            }
        }
    }

    /// Connect settlements in a trade ring: A↔B↔C↔D↔A.
    pub fn connect_trade_ring(&mut self, settlements: &[u64]) {
        if settlements.len() < 2 {
            return;
        }
        for window in settlements.windows(2) {
            self.make_trade_route(window[0], window[1]);
        }
        if settlements.len() > 2 {
            self.make_trade_route(*settlements.last().unwrap(), settlements[0]);
        }
    }

    /// Connect all settlements to a central trade hub.
    pub fn connect_trade_hub(&mut self, hub: u64, spokes: &[u64]) {
        for &spoke in spokes {
            self.make_trade_route(hub, spoke);
        }
    }

    // -- Pre-build query API --

    /// Look up an entity by ID without consuming the scenario.
    pub fn entity(&self, id: u64) -> Option<&Entity> {
        self.world.entities.get(&id)
    }

    /// Find an entity by name (first match). Returns the entity ID.
    pub fn find_by_name(&self, name: &str) -> Option<u64> {
        self.world
            .entities
            .values()
            .find(|e| e.name == name)
            .map(|e| e.id)
    }

    /// Count living entities of a given kind.
    pub fn count_living(&self, kind: &EntityKind) -> usize {
        self.world.count_living(kind)
    }

    /// Get all living entity IDs of a given kind.
    pub fn living_ids(&self, kind: &EntityKind) -> Vec<u64> {
        self.world.living_entities(kind)
    }

    // -- Builder-style creation --

    /// Create a faction and return a builder ref for chaining field mutations.
    /// Uses the same defaults as [`add_faction`](Scenario::add_faction) (treasury=100).
    pub fn faction(&mut self, name: &str) -> FactionRef<'_> {
        let id = self.add_faction(name);
        FactionRef { scenario: self, id }
    }

    /// Create a settlement and return a builder ref for chaining field mutations.
    /// Uses the same defaults as [`add_settlement`](Scenario::add_settlement) (pop=200, prosperity=0.5).
    pub fn settlement(&mut self, name: &str, faction: u64, region: u64) -> SettlementRef<'_> {
        let id = self.add_settlement(name, faction, region);
        SettlementRef { scenario: self, id }
    }

    /// Create a person with MemberOf→faction and return a builder ref.
    /// Uses the same defaults as [`add_person`](Scenario::add_person) (birth_year=start-30, sex="male").
    pub fn person(&mut self, name: &str, faction: u64) -> PersonRef<'_> {
        let id = self.add_person(name, faction);
        PersonRef { scenario: self, id }
    }

    /// Create a person with MemberOf→faction and LocatedIn→settlement, return a builder ref.
    pub fn person_in(&mut self, name: &str, faction: u64, settlement: u64) -> PersonRef<'_> {
        let id = self.add_person_in(name, faction, settlement);
        PersonRef { scenario: self, id }
    }

    /// Create a player character with MemberOf→faction and return a builder ref.
    /// Equivalent to [`add_player_in`](Scenario::add_player_in) but returns a builder.
    pub fn player_in(&mut self, name: &str, faction: u64) -> PersonRef<'_> {
        let id = self.add_player_in(name, faction);
        PersonRef { scenario: self, id }
    }

    /// Create an army and return a builder ref for chaining field mutations.
    /// Uses the same defaults as [`add_army`](Scenario::add_army) (morale=1.0, supply=3.0).
    pub fn army(&mut self, name: &str, faction: u64, region: u64, strength: u32) -> ArmyRef<'_> {
        let id = self.add_army(name, faction, region, strength);
        ArmyRef { scenario: self, id }
    }

    // -- Builder-style mutation (generated by scenario_ref_mut! macro) --
}

macro_rules! scenario_ref_mut {
    ($($method:ident, $Ref:ident, $as_ref:ident, $label:expr;)*) => {
        impl Scenario {
            $(
                pub fn $method(&mut self, id: u64) -> $Ref<'_> {
                    assert!(
                        self.world.entities.get(&id).and_then(|e| e.data.$as_ref()).is_some(),
                        "{}: entity {id} is not a {}", stringify!($method), $label
                    );
                    $Ref { scenario: self, id }
                }
            )*
        }
    };
}

scenario_ref_mut! {
    faction_mut, FactionRef, as_faction, "faction";
    settlement_mut, SettlementRef, as_settlement, "settlement";
    person_mut, PersonRef, as_person, "person";
    army_mut, ArmyRef, as_army, "army";
    building_mut, BuildingRef, as_building, "building";
    region_mut, RegionRef, as_region, "region";
    culture_mut, CultureRef, as_culture, "culture";
    disease_mut, DiseaseRef, as_disease, "disease";
    knowledge_mut, KnowledgeRef, as_knowledge, "knowledge";
    geographic_feature_mut, GeographicFeatureRef, as_geographic_feature, "geographic feature";
    river_mut, RiverRef, as_river, "river";
    resource_deposit_mut, ResourceDepositRef, as_resource_deposit, "resource deposit";
    manifestation_mut, ManifestationRef, as_manifestation, "manifestation";
    item_mut, ItemRef, as_item, "item";
    religion_mut, ReligionRef, as_religion, "religion";
    deity_mut, DeityRef, as_deity, "deity";
}

impl Scenario {
    /// Shorthand for `SimTimestamp::from_year(self.start_year)`.
    fn ts(&self) -> SimTimestamp {
        SimTimestamp::from_year(self.start_year)
    }

    // -- Output --

    /// Consume the scenario and return the constructed World.
    pub fn build(self) -> World {
        self.world
    }

    /// Build the world and run the given systems. Uses the scenario's start year.
    pub fn run(self, systems: &mut [Box<dyn SimSystem>], num_years: u32, seed: u64) -> World {
        let start_year = self.start_year;
        let mut world = self.build();
        run(
            &mut world,
            systems,
            SimConfig::new(start_year, num_years, seed),
        )
        .expect("simulation flush failed");
        world
    }

    /// Borrow the world for inspection.
    pub fn world(&self) -> &World {
        &self.world
    }

    /// Borrow the world mutably for additional modifications.
    pub fn world_mut(&mut self) -> &mut World {
        &mut self.world
    }
}
